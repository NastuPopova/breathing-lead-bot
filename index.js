const { Telegraf, Markup, session } = require('telegraf');
const config = require('./config');

let ExtendedSurveyQuestions, BreathingVERSEAnalysis, LeadTransferSystem, PDFBonusManager, AdminNotificationSystem;
try {
  ExtendedSurveyQuestions = require('./modules/survey/extended_questions');
  BreathingVERSEAnalysis = require('./modules/analysis/verse_analysis');
  LeadTransferSystem = require('./modules/integration/lead_transfer');
  PDFBonusManager = require('./modules/bonus/pdf_manager');
  AdminNotificationSystem = require('./modules/admin/notifications');
  console.log('‚úÖ –í—Å–µ –º–æ–¥—É–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ');
} catch (error) {
  console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π:', error.message);
  process.exit(1);
}

class BreathingLeadBot {
  constructor() {
    this.bot = new Telegraf(config.LEAD_BOT_TOKEN);
    this.surveyQuestions = new ExtendedSurveyQuestions();
    this.verseAnalysis = new BreathingVERSEAnalysis();
    this.leadTransfer = new LeadTransferSystem();
    this.pdfManager = new PDFBonusManager();
    this.adminNotifications = new AdminNotificationSystem(this.bot);

    this.setupMiddleware();
    this.setupHandlers();
    this.setupErrorHandling();
  }

  setupMiddleware() {
    this.bot.use(session({
      defaultSession: () => ({
        currentQuestion: null,
        answers: {},
        multipleChoiceSelections: {},
        startTime: Date.now(),
        questionStartTime: Date.now(),
        completedQuestions: [],
        navigationHistory: []
      })
    }));

    this.bot.use(async (ctx, next) => {
      const messageText = ctx.message?.text || ctx.callbackQuery?.data || 'callback';
      console.log(`[${new Date().toISOString()}] User ${ctx.from?.id || 'unknown'}: ${messageText}`);

      if (!ctx.session) {
        console.warn('‚ö†Ô∏è –°–µ—Å—Å–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–æ–≤—É—é');
        ctx.session = this.getDefaultSession();
      }
      return next();
    });
  }

  getDefaultSession() {
    return {
      currentQuestion: null,
      answers: {},
      multipleChoiceSelections: {},
      startTime: Date.now(),
      questionStartTime: Date.now(),
      completedQuestions: [],
      navigationHistory: []
    };
  }

  setupHandlers() {
    this.bot.start(ctx => this.handleStart(ctx));
    this.bot.command('reset', ctx => this.handleReset(ctx));
    this.bot.command('help', ctx => this.handleHelp(ctx));
    this.bot.command('about', ctx => this.handleAbout(ctx));
    this.bot.command('contact', ctx => this.handleContact(ctx));
    this.bot.action(/^download_(.+)$/, ctx => this.handlePDFDownload(ctx));
    this.bot.action(/^download_pdf_(.+)$/, ctx => this.handleAdditionalPDFDownload(ctx));
    this.bot.action('more_materials', ctx => this.handleMoreMaterials(ctx));
    this.bot.action('pdf_error_retry', ctx => this.handlePDFRetry(ctx));
    this.bot.command('pdf_stats', ctx => this.handleAdminPDFStats(ctx));
    this.bot.command('test_pdf', ctx => this.handleTestPDF(ctx));
    this.bot.action(/^admin_(.+)_(\d+)$/, ctx => this.handleAdminAction(ctx));
    this.bot.on('callback_query', ctx => this.handleCallback(ctx));
    this.bot.on('text', ctx => this.handleText(ctx));
  }

  setupErrorHandling() {
    this.bot.catch(async (err, ctx) => {
      console.error('üí• –û—à–∏–±–∫–∞ –±–æ—Ç–∞:', err);
      await this.sendErrorMessage(ctx, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start');
    });
  }

  async handleStart(ctx) {
    try {
      ctx.session = this.getDefaultSession();
      const welcomeMessage = `üå¨Ô∏è *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É –¥—ã—Ö–∞–Ω–∏—è!*\n\n` +
        `–ü—Ä–∏–≤–µ—Ç, ${ctx.from.first_name}! –Ø –ø–æ–º–æ–≥—É –ø–æ–¥–æ–±—Ä–∞—Ç—å —Ç–µ—Ö–Ω–∏–∫–∏ –¥—ã—Ö–∞–Ω–∏—è.\n` +
        `–ó–∞ 4-5 –º–∏–Ω—É—Ç –æ–ø—Ä–µ–¥–µ–ª–∏–º –≤–∞—à–∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–∏ –∏ –¥–∞–¥–∏–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏.\n\n` +
        `*–ù–æ–≤–æ–µ:* –∫–Ω–æ–ø–∫–∞ "‚¨ÖÔ∏è –ù–∞–∑–∞–¥" –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞!`;

      await ctx.reply(welcomeMessage, {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üöÄ –ù–∞—á–∞—Ç—å', 'start_survey')],
          [Markup.button.callback('‚ÑπÔ∏è –ü–æ–¥—Ä–æ–±–Ω–µ–µ', 'about_survey')]
        ])
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ /start:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞');
    }
  }

  async handleReset(ctx) {
    try {
      ctx.session = this.getDefaultSession();
      await ctx.reply('üîÑ –°–µ—Å—Å–∏—è —Å–±—Ä–æ—à–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ: /start');
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ /reset:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞');
    }
  }

  async handleHelp(ctx) {
    const helpMessage = `üå¨Ô∏è *–ü–û–ú–û–©–¨ –ü–û –î–ò–ê–ì–ù–û–°–¢–ò–ö–ï –î–´–•–ê–ù–ò–Ø*\n\n` +
      `üöÄ */start* - –ù–∞—á–∞—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É –¥—ã—Ö–∞–Ω–∏—è\n` +
      `üîÑ */reset* - –°–±—Ä–æ—Å–∏—Ç—å –∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ\n` +
      `‚ùì */help* - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n\n` +
      `üìã *–û –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–µ:*\n` +
      `‚Ä¢ 4-7 –º–∏–Ω—É—Ç –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–π –∞–Ω–∫–µ—Ç—ã\n` +
      `‚Ä¢ –ê–Ω–∞–ª–∏–∑ –ø–æ –º–µ—Ç–æ–¥—É VERSE\n` +
      `‚Ä¢ –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ PDF-–≥–∏–¥—ã —Å —Ç–µ—Ö–Ω–∏–∫–∞–º–∏\n` +
      `‚Ä¢ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏\n` +
      `‚Ä¢ –î–µ—Ç—Å–∫–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Ä–æ–¥–∏—Ç–µ–ª–µ–π\n\n` +
      `üë©‚Äç‚öïÔ∏è *–¢—Ä–µ–Ω–µ—Ä:* –ê–Ω–∞—Å—Ç–∞—Å–∏—è –ü–æ–ø–æ–≤–∞\n` +
      `üí¨ *–õ–∏—á–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç:* @NastuPopova`;

    await ctx.reply(helpMessage, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('üöÄ –ù–∞—á–∞—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É', 'start_survey')],
        [Markup.button.url('üí¨ –ù–∞–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–Ω–µ—Ä—É', 'https://t.me/NastuPopova')]
      ])
    });
  }

  async handleAbout(ctx) {
    const aboutMessage = `üå¨Ô∏è *–î–´–•–ê–¢–ï–õ–¨–ù–´–ï –ü–†–ê–ö–¢–ò–ö–ò*\n\n` +
      `–î—ã—Ö–∞–Ω–∏–µ ‚Äî –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ä–≥–∞–Ω–∏–∑–º–∞, –∫–æ—Ç–æ—Ä–æ–π –º—ã –º–æ–∂–µ–º —É–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–∑–Ω–∞—Ç–µ–ª—å–Ω–æ. ` +
      `–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Ç–µ—Ö–Ω–∏–∫–∏ –ø–æ–º–æ–≥–∞—é—Ç:\n\n` +
      `üî• *–°—Ä–æ—á–Ω–æ:*\n` +
      `‚Ä¢ –°–Ω—è—Ç—å —Å—Ç—Ä–µ—Å—Å –∑–∞ 2-3 –º–∏–Ω—É—Ç—ã\n` +
      `‚Ä¢ –°–ø—Ä–∞–≤–∏—Ç—å—Å—è —Å –ø–∞–Ω–∏–∫–æ–π\n` +
      `‚Ä¢ –ë—ã—Å—Ç—Ä–æ –∑–∞—Å–Ω—É—Ç—å\n\n` +
      `üéØ *–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ:*\n` +
      `‚Ä¢ –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–∞–≤–ª–µ–Ω–∏–µ\n` +
      `‚Ä¢ –£–ª—É—á—à–∏—Ç—å —Å–æ–Ω –∏ —ç–Ω–µ—Ä–≥–∏—é\n` +
      `‚Ä¢ –ü–æ–≤—ã—Å–∏—Ç—å –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏—é\n` +
      `‚Ä¢ –£–∫—Ä–µ–ø–∏—Ç—å –∏–º–º—É–Ω–∏—Ç–µ—Ç\n\n` +
      `üìö –ú–µ—Ç–æ–¥—ã –æ—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞ —Ä–∞–±–æ—Ç–∞—Ö –ö.–ü. –ë—É—Ç–µ–π–∫–æ, –ê.–ù. –°—Ç—Ä–µ–ª—å–Ω–∏–∫–æ–≤–æ–π –∏ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è—Ö.`;

    await ctx.reply(aboutMessage, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('üöÄ –ü—Ä–æ–π—Ç–∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É', 'start_survey')],
        [Markup.button.callback('üìû –ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è', 'contact_request')]
      ])
    });
  }

  async handleContact(ctx) {
    await this.handleContactRequest(ctx);
  }

  async handleCallback(ctx) {
    const data = ctx.callbackQuery.data;
    try {
      if (!ctx.session.answers) {
        console.warn('‚ö†Ô∏è Answers –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º');
        return this.handleStart(ctx);
      }

      if (data === 'nav_back') {
        await this.handleBackNavigation(ctx);
      } else if (data === 'start_survey') {
        await this.startSurvey(ctx);
      } else if (data === 'about_survey') {
        await this.showSurveyInfo(ctx);
      } else if (data === 'contact_request') {
        await this.handleContactRequest(ctx);
      } else if (data === 'back_to_start') {
        await this.handleStart(ctx);
      } else if (data === 'back_to_results') {
        await this.showResults(ctx);
      } else {
        await this.handleSurveyAnswer(ctx, data);
      }

      await ctx.answerCbQuery();
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ callback:', error, { data });
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏');
    }
  }

  async handleAdminAction(ctx) {
    const action = ctx.match[1];
    const targetUserId = ctx.match[2];
    await this.adminNotifications.handleAdminCallback(ctx, action, targetUserId);
    await ctx.answerCbQuery();
  }

  async handleContactRequest(ctx) {
    try {
      const contactMessage = config.MESSAGES.CONTACT_TRAINER;
      
      await ctx.editMessageText(contactMessage, {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.url('üë©‚Äç‚öïÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å –ê–Ω–∞—Å—Ç–∞—Å–∏–∏', `https://t.me/${config.TRAINER_CONTACT.replace('@', '')}`)],
          [Markup.button.callback('üîô –ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º', 'back_to_results')],
          [Markup.button.callback('üéÅ –ú–∞—Ç–µ—Ä–∏–∞–ª—ã', 'free_materials')]
        ])
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ handleContactRequest:', error);
      await ctx.reply(config.MESSAGES.CONTACT_TRAINER, { parse_mode: 'Markdown' });
    }
  }

  async showResults(ctx) {
    try {
      if (!ctx.session.analysisResult) {
        return this.handleStart(ctx);
      }

      const bonus = this.pdfManager.getBonusForUser(
        ctx.session.analysisResult, 
        ctx.session.answers
      );
      
      const message = this.pdfManager.generateBonusMessage(bonus, ctx.session.analysisResult);
      const keyboard = this.pdfManager.generateBonusKeyboard(bonus, 'file');

      await ctx.editMessageText(message, {
        parse_mode: 'Markdown',
        ...keyboard
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ showResults:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤');
    }
  }

  async handleBackNavigation(ctx) {
    try {
      const currentQuestion = ctx.session.currentQuestion;
      if (!currentQuestion) {
        console.log('‚ö†Ô∏è –ù–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞');
        return this.handleStart(ctx);
      }

      const previousQuestion = this.surveyQuestions.getPreviousQuestion(
        currentQuestion,
        ctx.session.answers
      );

      if (!previousQuestion) {
        await ctx.reply('–í—ã –≤ –Ω–∞—á–∞–ª–µ –∞–Ω–∫–µ—Ç—ã! –ù–∞–∂–º–∏—Ç–µ /start');
        return;
      }

      if (ctx.session.answers[currentQuestion]) {
        delete ctx.session.answers[currentQuestion];
      }
      if (ctx.session.multipleChoiceSelections[currentQuestion]) {
        delete ctx.session.multipleChoiceSelections[currentQuestion];
      }
      const index = ctx.session.completedQuestions.indexOf(currentQuestion);
      if (index !== -1) {
        ctx.session.completedQuestions.splice(index, 1);
      }

      ctx.session.currentQuestion = previousQuestion;
      ctx.session.questionStartTime = Date.now();
      await this.askQuestion(ctx, previousQuestion);
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –Ω–∞–∑–∞–¥:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏');
    }
  }

  async startSurvey(ctx) {
    try {
      ctx.session.currentQuestion = 'age_group';
      ctx.session.questionStartTime = Date.now();
      await this.askQuestion(ctx, 'age_group');
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ startSurvey:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –Ω–∞—á–∞–ª–∞ –∞–Ω–∫–µ—Ç—ã');
    }
  }

  async showSurveyInfo(ctx) {
    try {
      const infoMessage = `üìã *–û –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–µ:*\n\n` +
        `üîç 18+ –≤–æ–ø—Ä–æ—Å–æ–≤ –æ –∑–¥–æ—Ä–æ–≤—å–µ –∏ —Ü–µ–ª—è—Ö\n` +
        `üë∂ –î–µ—Ç—Å–∫–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Ä–æ–¥–∏—Ç–µ–ª–µ–π\n` +
        `üß† –ê–Ω–∞–ª–∏–∑ VERSE –æ—Ç —ç–∫—Å–ø–µ—Ä—Ç–æ–≤\n` +
        `üéØ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏\n` +
        `‚è±Ô∏è 4-7 –º–∏–Ω—É—Ç\n` +
        `üîí –ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ\n` +
        `üíù –ë–µ—Å–ø–ª–∞—Ç–Ω–æ`;

      await ctx.editMessageText(infoMessage, {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üöÄ –ù–∞—á–∞—Ç—å', 'start_survey')],
          [Markup.button.callback('üîô –ù–∞–∑–∞–¥', 'back_to_start')]
        ])
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ showSurveyInfo:', error);
      await ctx.reply(infoMessage, { parse_mode: 'Markdown' });
    }
  }

  async askQuestion(ctx, questionId) {
    try {
      if (!ctx.session?.answers) {
        console.warn('‚ö†Ô∏è –ù–µ—Ç answers, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫');
        return this.handleStart(ctx);
      }

      const question = this.surveyQuestions.getQuestion(questionId);
      if (!question) {
        console.error('‚ùå –í–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω:', questionId);
        return this.completeSurvey(ctx);
      }

      if (!this.surveyQuestions.shouldShowQuestion(questionId, ctx.session.answers)) {
        console.log(`üîç –£—Å–ª–æ–≤–∏–µ –¥–ª—è "${questionId}": false`);
        return this.moveToNextQuestion(ctx);
      }

      const progress = this.surveyQuestions.getProgress(
        ctx.session.completedQuestions,
        ctx.session.answers
      );

      let message = `${this.generateProgressBar(progress.percentage)} *${progress.completed}/${progress.total}*\n\n${question.text}`;

      if (question.type === 'multiple_choice') {
        const selections = ctx.session.multipleChoiceSelections[questionId] || [];
        if (selections.length > 0) {
          const translatedSelections = this.getTranslatedSelections(selections);
          message += `\n\n*–í—ã–±—Ä–∞–Ω–æ (${selections.length}):*\n${translatedSelections.map(s => `‚Ä¢ ${s}`).join('\n')}`;
        }
      }

      if (this.surveyQuestions.isChildFlow(ctx.session.answers)) {
        message += `\n\nüë∂ *–î–µ—Ç—Å–∫–∞—è –≤–µ—Ä—Å–∏—è*`;
      }

      try {
        await ctx.editMessageText(message, {
          parse_mode: 'Markdown',
          ...question.keyboard
        });
      } catch {
        await ctx.reply(message, {
          parse_mode: 'Markdown',
          ...question.keyboard
        });
      }
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ askQuestion:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –≤–æ–ø—Ä–æ—Å–∞');
    }
  }

  getTranslatedSelections(selections) {
    return selections.map(selection => {
      return config.TRANSLATIONS[selection] || selection;
    });
  }

  async handleSurveyAnswer(ctx, callbackData) {
    try {
      const questionId = ctx.session.currentQuestion;
      if (!questionId || !ctx.session.answers) {
        console.warn('‚ö†Ô∏è –ù–µ—Ç –≤–æ–ø—Ä–æ—Å–∞/–æ—Ç–≤–µ—Ç–æ–≤');
        return this.handleStart(ctx);
      }

      const question = this.surveyQuestions.getQuestion(questionId);
      if (!question) {
        console.error('‚ùå –í–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω:', questionId);
        return this.handleStart(ctx);
      }

      if (questionId === 'stress_level') {
        this.debugStressLevelCallback(ctx, callbackData);
      }

      const mappedValue = this.surveyQuestions.mapCallbackToValue(callbackData);
      console.log(`üîç –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è "${questionId}": ${mappedValue}`);
      
      if (mappedValue === undefined || mappedValue === null) {
        console.error('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π callback:', callbackData);
        await ctx.answerCbQuery('–û—à–∏–±–∫–∞ –æ—Ç–≤–µ—Ç–∞', { show_alert: true });
        return;
      }

      if (question.type === 'multiple_choice') {
        return this.handleMultipleChoice(ctx, questionId, mappedValue, callbackData);
      }

      const validation = this.surveyQuestions.validateAnswer(questionId, callbackData);
      if (!validation.valid) {
        await ctx.answerCbQuery(validation.error, { show_alert: true });
        return;
      }

      ctx.session.answers[questionId] = mappedValue;
      console.log(`üîç –¢–µ–∫—É—â–∏–µ –æ—Ç–≤–µ—Ç—ã:`, ctx.session.answers);
      if (!ctx.session.completedQuestions.includes(questionId)) {
        ctx.session.completedQuestions.push(questionId);
      }

      if (questionId === 'stress_level') {
        const stressLevel = mappedValue;
        let feedbackMessage = `‚úÖ –í—ã –≤—ã–±—Ä–∞–ª–∏ —É—Ä–æ–≤–µ–Ω—å —Å—Ç—Ä–µ—Å—Å–∞: ${stressLevel}`;
        if (validation.warning) {
          feedbackMessage += `\n${validation.warning}`;
        }
        await ctx.answerCbQuery(feedbackMessage, { show_alert: true });
      }

      await this.moveToNextQuestion(ctx);
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ handleSurveyAnswer:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –æ—Ç–≤–µ—Ç–∞');
    }
  }

  async handleMultipleChoice(ctx, questionId, value, callbackData) {
    try {
      if (!ctx.session.multipleChoiceSelections[questionId]) {
        ctx.session.multipleChoiceSelections[questionId] = [];
      }
      const selections = ctx.session.multipleChoiceSelections[questionId];

      if (callbackData.includes('done')) {
        const validation = this.surveyQuestions.validateAnswer(questionId, 'done', selections);
        if (!validation.valid) {
          await ctx.answerCbQuery(validation.error, { show_alert: true });
          return;
        }
        ctx.session.answers[questionId] = [...selections];
        if (!ctx.session.completedQuestions.includes(questionId)) {
          ctx.session.completedQuestions.push(questionId);
        }
        return this.moveToNextQuestion(ctx);
      }

      const index = selections.indexOf(value);
      if (index > -1) {
        selections.splice(index, 1);
        const translatedValue = config.TRANSLATIONS[value] || value;
        await ctx.answerCbQuery(`‚ùå –£–±—Ä–∞–Ω–æ: ${translatedValue}`);
      } else {
        const validation = this.surveyQuestions.validateAnswer(questionId, value, selections);
        if (!validation.valid) {
          await ctx.answerCbQuery(validation.error, { show_alert: true });
          return;
        }
        selections.push(value);
        const translatedValue = config.TRANSLATIONS[value] || value;
        await ctx.answerCbQuery(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: ${translatedValue}`);
      }
      
      await this.askQuestion(ctx, questionId);
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ handleMultipleChoice:', error);
      await this.sendErrorMessage(ctx, '–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞');
